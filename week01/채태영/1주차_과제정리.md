# 1주차 과제

- 데이터 입력 및 분류 코드
    
    ```python
    fish_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0,
                    31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0,
                    35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0, 9.8,
                    10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]
    fish_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0,
                    500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0,
                    700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0, 6.7,
                    7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9]
    
    import numpy as np
    fish_data = np.column_stack((fish_length, fish_weight))
    fish_target = np.concatenate((np.ones(35), np.zeros(14)))
    
    from sklearn.model_selection import train_test_split
    train_input, test_input, train_target, test_target = train_test_split(
        fish_data, fish_target, stratify = fish_target, random_state=42)
    
    from sklearn.neighbors import KNeighborsClassifier
    kn = KNeighborsClassifier()
    ```
    
- 데이터 스케일링을 거치지 않은 코드
    
    ```python
    import matplotlib.pyplot as plt
    
    distances, indexes = kn.kneighbors([[25, 150]])
    
    plt.scatter(train_input[:,0], train_input[:,1])
    plt.scatter(25, 150, marker='^')
    plt.scatter(train_input[indexes,0], train_input[indexes,1], marker='D')
    plt.xlabel('length')
    plt.ylabel('weight')
    plt.show(
    ```
    
- 데이터 스케일링을 한 코드
    
    ```python
    mean = np.mean(train_input, axis = 0)
    std = np.std(train_input, axis = 0)
    
    train_scaled = (train_input - mean) / std
    new = ([25, 150] - mean) / std
    
    distances, indexes = kn.kneighbors([new])
    plt.scatter(train_scaled[:,0], train_scaled[:,1])
    plt.scatter(new[0], new[1], marker='^')
    plt.scatter(train_scaled[indexes,0], train_scaled[indexes,1], marker='D')
    plt.xlabel('length')
    plt.ylabel('weight')
    plt.sho
    ```
    

- 데이터 스케일링을 거치지 않았을때
    1. 주황색 세모는 우리가 예측하고자 하는 샘플의 값으로 (25, 150)이다. 
    2. 초록색 마름모는 kneighbors를 사용하여 샘플과 가장 가까운 이웃 5개를 나타낸것이다.
    3. 수치상으로는 그래프 우측 상단쪽에 있는 무리로 분류가 되어야하지만 그래프와 코드출력을 보면 좌측 하단의 무리로 분류된다
        1. 현재 이 데이터는 스케일링을 하지 않은 상태이기 때문에 x축, y축의 범위가 달라도 단순 거리로 가까운 이웃이 많은 무리로 분류되기 때문에 부적합하다.
            
            <img width="600" height="450" alt="image" src="https://github.com/user-attachments/assets/272be54f-f3d5-450d-9c77-605967f33e6e" />

            
- 데이터 스케일링을 거쳤을때
    1. 표준편차를 이용하여 샘플의 기준을 동일하게 맞춰주었으며 실제 특성값의 크기와 상관없이 동일한 조건으로 비교가능하다.
    2. 동일한 조건을 가지고 비교했을때의 그래프를 살펴보면 찾고자하는 샘플이 우측상단 무리에 분류되는것을 볼 수 있다.
        
        <img width="600" height="450" alt="image 1" src="https://github.com/user-attachments/assets/992fc5be-4fd6-4f70-a98b-4483c12c526c" />
